[TOC]#2016年4月25日##javascript###数值JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。```js1 === 1.0 // true1 + 1.0 // 2```由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。```js0.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false```>浮点数：采用了IEEE-745浮点数表示法，可以精确地表示分数，遗憾的是，我们常用的分数（特别是在金融的计算方面）都是十进制分数1/10，1/100等。二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字。>http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html - **数值的表示法**以下两种情况，JavaScript会自动将数值转为科学计数法表示1. 小数点前的数字多于21位。2. 小数点后的零多于5个。 - **数值的进制**使用字面量（literal）时，JavaScript对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。1. 十进制：没有前导0的数值。2. 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的七个阿拉伯数字的数值。3. 十六进制：有前缀0x或0X的数值。4. 二进制：有前缀0b或0B的数值。 - **NAN**NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。        typeof NaN // 'number'    isNaN(NaN) // true>isNaN方法可以用来判断一个值是否为NaN。判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断。    function myIsNaN(value) {return value !== value;} - **parseInt()****parseInt**方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。参数不是字符串，则会先转为字符串再转换。```jsparseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15```parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制,第二个参数默认为10。```jsparseInt('1000') // 1000parseInt('1000', 10) // 1000```如果第二个参数不是数值，会被自动转为一个整数。如果第二个参数是0、undefined和null，则直接忽略。字符串包含对于指定进制无意义的字符，则返回NaN。 - **parseFloat()**parseFloat方法用于将一个字符串转为浮点数。    parseFloat('314e-2') // 3.14    parseFloat('0.0314E+2') // 3.14 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。```jsparseFloat([]) // NaNparseFloat('FF2') // NaNparseFloat('') // NaNparseFloat('\t\v\r12.34\n ') // 12.34```###原型原型：CSS中Class普通方法：CSS中的style原型：prototype:要写在构造函数下面。```jsvar arr=[1,2,3,4,5];Array.prototype.sum=function(){    var result=0;    for(var i=0;i<this.length;i++){        result+=this[i];    }    return result;}alert(arr.sum());    ```面向对象的原型写法：```jsfunction 构造函数(){    this.属性}构造函数.原型.方法=function(){};var 对象1=new 构造函数();对象1.方法();```**Array.__proto__**提供的是 数组原型 – 请把它当作 Array 函数所继承的对象。而**Array.protoype**，提供的的是 所有数组的原型对象。```jsvar Point = function (x, y) {    this.x = x;    this.y = y;}Point.prototype.add = function (otherPoint) {    this.x += otherPoint.x;    this.y += otherPoint.y;}var p1 = new Point(3, 4);var p2 = new Point(8, 6);p1.add(p2);```>http://blog.jobbole.com/66441/